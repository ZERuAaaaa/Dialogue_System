package org.multiAgent;

import javafx.util.Pair;
import org.multiAgent.BroadCastCommunication.Messager;
import org.multiAgent.BroadCastCommunication.Move;
import org.multiAgent.BroadCastCommunication.MoveType;
import org.multiAgent.IVAFramework.Argument;
import org.multiAgent.Models.Model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

/**
 * this class implemented a dialogue system
 */
public class DialogueSystem {

    public static ArrayList<Agent> agents = new ArrayList<>();
    // the dialogue maintains a logger recording every move of agents
    public static Messager messager = new Messager();
    public static int counter = 0;
    public static String topic = null;

    public void reset(){
        topic = null;
        messager = new Messager();
        agents.clear();
        counter = 0;
        Agent.AgentCounter = 0;
    }
    /**
     * default constructor
     */
    public DialogueSystem(){

    }

    /**
     * add new agent to the dialogue
     * @param audiences audiences of the new agent
     * @param arguments arguments of the new agent
     */
    public void addAgent(HashMap<String, Integer> audiences, ArrayList<Argument> arguments, Model model){
        agents.add(new Agent(audiences, arguments, model));
    }

    /**
     * start the dialogue under a topic
     * @param topic topic
     * @return 1 if is an agreed close, -1 if it's a match close
     */
    public Integer run(String topic){
        this.topic = topic;
        // the dialogue opened by the last agent in order
        Agent lastAgent = agents.get(agents.size() - 1);
        messager.broadCast(new Move(lastAgent,MoveType.OPEN,topic), lastAgent, agents);

        // initialize the model and dvaf of each agent
        //ArrayList<HashSet<String>> agreeable = new ArrayList<>();
        for (Agent age: agents){
            age.initializeByTopic(topic, getDialogueInfo());
            //agreeable.add(age.getAgreeableAction());
        }
        //HashSet<String> intersection = agreeable.get(0);
        //for (int i = 1 ; i < agreeable.size(); i++){
        //    intersection.retainAll(agreeable.get(i));
        //}
        //System.out.println(intersection);
        Integer close = 0;
        while(close == 0){
            for(Agent currentAgent: agents){
                currentAgent.updateModel(getDialoguePossibility());
                Move currentMove = currentAgent.Act(messager);
                messager.broadCast(currentMove, currentAgent, agents);
                close = messager.checkClose();
                //System.out.println("\n" + currentAgent.getAgentId());
                //currentAgent.getDvaf().print();
                //System.out.println(messager.getLastOne());
                if(close != 0){
                    break;
                }

                counter++;
            }

        }
        return close;
    }

    /**
     * return the information of the dialogue, agents and their audiences
     * @return info
     */
    public Pair<ArrayList<Agent>, HashMap<Agent, HashMap<String, Integer>>> getDialogueInfo(){
        HashMap<Agent, HashMap<String, Integer>> infoTable = new HashMap<>();
        for (Agent age: agents){
            infoTable.put(age,age.collectAgentInfo());
        }
        return new Pair<>(agents, infoTable);
    }

    /**
     * return all agents' possibility distribution generated by their model
     * @return possibility distribution
     */
    public HashMap<Agent, HashMap<String, Float>> getDialoguePossibility(){
        HashMap<Agent,HashMap<String, Float>> list = new HashMap<>();
        for (Agent age: agents){
            list.put(age, age.getPossibility());
        }
        return list;
    }
}
